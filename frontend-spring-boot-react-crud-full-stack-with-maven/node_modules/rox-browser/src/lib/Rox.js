import client from './RoxClient';
import { setDefaultFreezeOption } from './FreezeOptions';
import RoxBase from 'rox-base';
const { RoxLogger, Config: configuration, Repositories } = RoxBase;

class Rox {
  /**
   * Initiate connection with ROX servers for the application identified by the application key. The registered containers will be synced and Rox entities will get the appropriate values.
   * @param {String} appKey application key as appears in ROX dashboard
   * @param {Object} options optional configuration object
   */
  setup(appKey, options = {}) {
    RoxLogger.setVerboseMode(options.debugLevel);
    if (options.configuration) {
      configuration.setActive(options.configuration);
    }
    if (options.freeze) {
      setDefaultFreezeOption(options.freeze);
    }
    client.setKey(appKey);
    client.setup(options);
    client.sendState();
    if (options.disableNetworkFetch) {
      return client.fetchCacheOnly();
    } else {
      return client.fetchWithCacheAndProceed();
    }
  }

  fetch() {
    client && client.fetch();
  }

  setCustomStringProperty(key, value) {
    client.setCustomProperty(key, String, value);
  }

  setCustomNumberProperty(key, value) {
    client.setCustomProperty(key, Number, value);
  }

  setCustomBooleanProperty(key, value) {
    client.setCustomProperty(key, Boolean, value);
  }

  /**
   * Register a container of Rox entities by specifiying a namespace.
   * @param {String} name Container name
   * @param {Object} container Object literal whose properties are Rox entities
   */
  register(name, container) {
    client.register(name, container);
  }

  unfreeze(namespace) {
    client.unfreeze(namespace);
  }

  get flags() {
    return Repositories.Flags.flags;
  }

  get dynamicApi() {
    return client.dynamicApi;
  }

  setDynamicCustomPropertyRule(handler) {
    client.setDynamicCustomPropertyRule(handler);
  }
}

const instance = new Rox();
export default instance;
