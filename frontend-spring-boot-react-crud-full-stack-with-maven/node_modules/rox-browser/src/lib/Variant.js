import RoxBase from 'rox-base';
const { Variant: BaseVariant, CallContextTypes } = RoxBase.Entities;
const { RoxxParser } = RoxBase.Parsers;
import {
  freezeOptions,
  isFreezeOptionValid,
  getDefaultFreezeOption,
  defaultFreezeOptionForPlatform
} from './FreezeOptions';
import * as Overrider from './Overrider';
const Context = RoxBase.Context;
const parser = new RoxxParser();

export default class RoxVariantBrowser extends BaseVariant {
  constructor(defaultValue, options, { freeze } = {}, name) {
    super(defaultValue, options, name);
    if (freeze && !isFreezeOptionValid(freeze)) {
      throw new Error(`Freeze option is invalid ${freeze}`);
    }
    this._localFreeze = freeze;
    this._lastResultExplanation = {};
  }

  unfreeze() {
    this._frozen = false;
  }

  setLastResultToExperiment(value, collecor) {
    this._lastResultExplanation = {
      value: value,
      from: 'experiment',
      payload: {
        condition: this.condition,
        expressionEvaluation: collecor
      }
    };
  }

  setLastResultToDefault(value) {
    if (this.condition) {
      this._lastResultExplanation = {
        value: value,
        from: 'exception',
        payload: {
          condition: this.condition
        }
      };
    } else {
      this._lastResultExplanation = {
        value: value,
        from: 'default'
      };
    }
  }

  setLastResultToFreeze() {
    this._lastResultExplanation = {
      value: this._value,
      from: 'freeze',
      payload: {
        freezedBy:
          this._lastResultExplanation.from === 'freeze'
            ? this._lastResultExplanation.payload.freezedBy
            : this._lastResultExplanation
      }
    };
  }

  // set default, or calculate by condition (experiment), raises impression
  calculateCondition(callContext, context) {
    let calculatedValue = { didUseExperimentToEvaluate: false, value: this._defaultValue };

    let collecor = [];
    if (this.condition) {
      let mergedContext = Context.Actions.getMergedContextWithGlobal(context);
      let newValue = parser.evaluateExpression(this.condition, callContext, mergedContext, collecor);
      newValue = newValue && newValue.toString ? newValue.toString() : newValue;
      if (this._type === typeof newValue && newValue !== undefined) {
        calculatedValue = { didUseExperimentToEvaluate: true, value: newValue };
      }
    }
    callContext.dontInvokeFlagImpression || this._flagImpression(calculatedValue.value, context);
    if (!callContext.dontInvokeFlagImpression) {
      if (calculatedValue.didUseExperimentToEvaluate) {
        this.setLastResultToExperiment(calculatedValue.value, collecor);
      } else {
        this.setLastResultToDefault(calculatedValue.value);
      }
    }
    return calculatedValue;
  }

  getOneTimeValue(callContext, context) {
    const valueToReturn = this.calculateCondition(callContext, context);
    callContext.isExperimenting = valueToReturn.didUseExperimentToEvaluate;
    return valueToReturn.value;
  }

  getFreezedValue(callContext) {
    callContext.isExperimenting = this._isExperimenting;
    if (!callContext.dontInvokeFlagImpression) {
      this.setLastResultToFreeze();
    }
    return this._value;
  }

  // ignoring overrides, considering freeze
  getActiveValue(callContext, context) {
    // freeze=none
    if (this._freeze === freezeOptions.freezeOptionNone) {
      return this.getOneTimeValue(callContext, context);
    }

    // handle freeze!=none
    if (callContext.type === CallContextTypes.frozenOrCalc) {
      if (!this._frozen) {
        return this.getOneTimeValue(callContext, context);
      } else {
        return this.getFreezedValue(callContext);
      }
    }
    if (callContext.type === CallContextTypes.oneTimeCalc) {
      return this.getOneTimeValue(callContext, context);
    }
    if (!callContext.type || callContext.type === CallContextTypes.default) {
      if (!this._frozen) {
        const valueToSet = this.calculateCondition(callContext, context);
        this.setValue(valueToSet);
        this._frozen = true;
        callContext.isExperimenting = this._isExperimenting;
        return this._value;
      } else {
        return this.getFreezedValue(callContext);
      }
    }
    return this.getFreezedValue(callContext);
  }

  // uses overrides
  getInternalValue(callContext, context) {
    const overridenValue = this.overridenValue;
    if (overridenValue) {
      callContext.isExperimenting = true;
      this._lastResultExplanation = {
        value: overridenValue,
        from: 'override'
      };
      return overridenValue;
    }
    return this.getActiveValue(callContext, context);
  }

  getValue(context) {
    return this.getInternalValue({}, context);
  }

  // when freeze, _value and _isExperimenting should be sync, as freezed-value was dependent on if-this-freezed-value-calculated-with-condition
  setValue(newValue) {
    if (this._frozen) return;

    this._isExperimenting = newValue.didUseExperimentToEvaluate;
    this._value = newValue.value;
  }

  explainLastResult() {
    return this._lastResultExplanation;
  }

  peek(context) {
    let callContext = { dontInvokeFlagImpression: true, type: CallContextTypes.oneTimeCalc };
    return this.getInternalValue(callContext, context);
  }

  get _freeze() {
    return this._localFreeze || getDefaultFreezeOption() || defaultFreezeOptionForPlatform;
  }

  get overrider() {
    return Overrider;
  }
}
